import os
import shutil
from fastapi import FastAPI, File, UploadFile, HTTPException, Form
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
from pydantic import BaseModel
import uvicorn

from typing import Optional, List

# import the rag logic
from app.rag_processor import add_document_to_store, query_documnents, get_vector_store

# directory for uploads
UPLOAD_DIR = "temp_uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)


@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Application startup: Initializing vector store...")
    try:
        get_vector_store()
        print("Vector store initialized successfully on startup.")
        yield
    except Exception as e:
        print(f"Error initializing vector store on startup: {e}")
        yield  # still yield to let the app continue (optional)


# Initialize FastAPI app
app = FastAPI(
    title="DocumentAgent API",
    description="API for uploading documents and querying them using RAG",
    lifespan=lifespan,
)

# Pydantic Models for Request/Response


class QueryRequest(BaseModel):
    query: str


class SourceDocument(BaseModel):
    source: Optional[str] = None
    page: Optional[int] = None
    content_preview: Optional[str] = None


class QueryResponse(BaseModel):
    answer: str
    source_documents: Optional[list[SourceDocument]] = None


# API Endpoints


@app.post("/upload")
async def upload_document(file: UploadFile = File(...)):
    """Handles document uploads, processing, and ingestion into the vector store."""
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file provided.")

    # Basic file type validation
    allowed_extensions = {".pdf", ".txt"}
    _, file_extension = os.path.splitext(file.filename)
    if file_extension.lower() not in allowed_extensions:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported file type: {file_extension}. Allowed types: {', '.join(allowed_extensions)}",
        )

    temp_file_path = os.path.join(UPLOAD_DIR, file.filename)

    try:
        # Save the uploaded file temporarily
        print(f"Saving uploaded file to: {temp_file_path}")
        with open(temp_file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # process and add document to vector store
        print(f"Adding document {file.filename} to vector store...")
        processing_success = add_document_to_store(temp_file_path)

        # --- Immediate Simple Return ---
        if processing_success:
            print("Processing reported success. Returning standard JSONResponse.")
            # Return the absolute simplest response possible
            return JSONResponse(
                status_code=200,
                content={
                    "message": f"Document '{file.filename}' processed and added successfully."
                },
            )
        else:
            # If add_document_to_vector_store returned False explicitly
            print("Processing reported failure.")
            raise HTTPException(
                status_code=500,
                detail=f"Failed to process document '{file.filename}'. Check server logs for errors during processing.",
            )

    except HTTPException as e:
        # Re-raise HTTPExceptions directly
        raise e
    except Exception as e:
        # Catch any other exceptions (including potential JSON error if it happens before return)
        print(f"Error during file upload/processing in main.py: {e}")
        import traceback

        traceback.print_exc()  # Print traceback here too
        # Decide if processing_success flag matters here, likely not if exception occurred
        raise HTTPException(
            status_code=500, detail=f"An unexpected error occurred in API endpoint: {e}"
        )
    finally:
        # Clean up the temporary file
        if os.path.exists(temp_file_path):
            try:
                os.remove(temp_file_path)
                print(f"Removed temporary file: {temp_file_path}")
            except Exception as e_clean:
                print(f"Error removing temporary file {temp_file_path}: {e_clean}")
        if file and not file.file.closed:
            file.file.close()


@app.post("/query", response_model=QueryResponse)
async def query_agent(request: QueryRequest):
    """Receives a query and returns the answer generated by the QA chain based on the ingested documents."""
    if not request.query:
        raise HTTPException(status_code=400, detail="Query cannot be empty.")

    try:
        print(f"Handling query via API: '{request.query}'")
        result = query_documnents(request.query)
        # The query_documents function now returns a dict matching QueryResponse structure
        return QueryResponse(**result)
    except Exception as e:
        print(f"Error processing query via API: {e}")
        # Return a structured error response
        error_response = QueryResponse(
            answer=f"An error occurred processing your query: {e}", source_documents=[]
        )
        # We could return status 500 here, but returning 200 with error message in payload
        # might be acceptable depending on API design philosophy. Let's stick to 500 for actual processing errors.
        raise HTTPException(status_code=500, detail=f"Failed to process query: {e}")


# --- Run the API (for local development) ---
if __name__ == "__main__":
    print("Starting FastAPI server...")
    uvicorn.run(app, host="0.0.0.0", port=8000)

    # To run: python main.py
    # Access API docs at http://127.0.0.1:8000/docs
